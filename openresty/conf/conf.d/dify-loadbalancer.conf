# Dify OpenResty负载均衡配置 (x86优化)

# Lua初始化
init_worker_by_lua_block {
    local loadbalancer = require "app.loadbalancer"
    loadbalancer.init()
}

# 限流区域定义（x86性能更强，可以设置更高的限制）
limit_req_zone $binary_remote_addr zone=per_ip:20m rate=200r/s;
limit_req_zone $app_type zone=per_app:20m rate=500r/s;
limit_req_zone $app_type:$user_id zone=per_app_user:50m rate=50r/s;

server {
    listen 80;
    listen [::]:80;
    server_name _;

    # 变量声明
    set $proxy_target "";
    set $app_type "";
    set $user_id "";
    set $backend_instance "";
    set $hash_key "";

    # 访问日志
    access_log /dev/stdout app_routing;
    error_log /dev/stdout info;

    # 安全头设置
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-Served-By "openresty-x86_64" always;

    # 健康检查
    location /health {
        access_log off;
        content_by_lua_block {
            ngx.say("healthy")
        }
    }

    # 负载均衡状态
    location /status {
        access_log off;
        content_by_lua_block {
            local loadbalancer = require "app.loadbalancer"
            local cjson = require "cjson"

            ngx.header.content_type = "application/json"

            local stats = loadbalancer.get_stats()
            local status = {
                status = "running",
                architecture = "x86_64",
                algorithm = "consistent_hash",
                stats = stats,
                timestamp = ngx.time()
            }

            ngx.say(cjson.encode(status))
        }
    }

    # 配置重载
    location /reload-config {
        access_log off;
        content_by_lua_block {
            -- 清空Hash环缓存，强制重新加载配置
            local hash_ring_dict = ngx.shared.hash_ring
            hash_ring_dict:flush_all()

            local loadbalancer = require "app.loadbalancer"
            loadbalancer.init()

            ngx.header.content_type = "application/json"
            ngx.say('{"status": "success", "message": "Configuration reloaded"}')
        }
    }

    # 主要API路由
    location /v1/ {
        # Lua变量声明
        set $app_type "";
        set $user_id "";
        set $backend_instance "";
        set $hash_key "";

        # 请求处理
        access_by_lua_block {
            local loadbalancer = require "app.loadbalancer"

            -- 1. 提取用户Token
            local auth_header = ngx.var.http_authorization
            ngx.log(ngx.INFO, "[DEBUG] Authorization header: ", auth_header or "nil")
            
            local user_token = ""
            if auth_header then
                user_token = string.match(auth_header, "Bearer%s+(.+)")
                ngx.log(ngx.INFO, "[DEBUG] Extracted user_token: ", user_token or "nil")
            else
                ngx.log(ngx.WARN, "[DEBUG] No Authorization header found")
            end

            -- 2. 验证Token并获取应用类型
            local app_type = loadbalancer.get_app_type(user_token)
            ngx.log(ngx.INFO, "[DEBUG] App type result: ", app_type or "nil")
            
            if not app_type then
                ngx.log(ngx.ERR, "[ERROR] Token validation failed for token: ", user_token or "nil")
                ngx.status = 401
                ngx.header.content_type = "application/json"
                ngx.say('{"error": "Invalid or missing authorization token"}')
                ngx.exit(401)
            end

            -- 3. 获取用户ID
            local user_id = loadbalancer.get_user_id()
            if not user_id then
                ngx.status = 400
                ngx.header.content_type = "application/json"
                ngx.say('{"error": "User ID required via X-User-ID header, user_id parameter, cookie, JSON body user field, or form-data user field"}')
                ngx.exit(400)
            end

            -- 4. 获取后端实例
            local instance, hash_key = loadbalancer.get_backend_instance(app_type, user_id)
            if not instance then
                ngx.status = 503
                ngx.header.content_type = "application/json"
                ngx.say('{"error": "Service temporarily unavailable"}')
                ngx.exit(503)
            end

            -- 5. 设置变量供后续使用
            ngx.var.app_type = app_type
            ngx.var.user_id = user_id
            ngx.var.backend_instance = instance.name
            ngx.var.hash_key = hash_key

            -- 6. 设置代理目标
            local proxy_url = "http://" .. instance.host .. ":" .. instance.port
            ngx.var.proxy_target = proxy_url

            -- 7. 设置真实Dify Token
            ngx.req.set_header("Authorization", "Bearer " .. instance.token)

            -- 8. 设置调试头
            ngx.req.set_header("X-App-Type", app_type)
            ngx.req.set_header("X-Dify-Instance", instance.name)
            ngx.req.set_header("X-User-ID-Used", user_id)
            ngx.req.set_header("X-Hash-Key", hash_key)
            ngx.req.set_header("X-LB-Architecture", "x86_64-OpenResty")
        }

        # 限流配置
        limit_req zone=per_app_user burst=100 nodelay;
        limit_req zone=per_app burst=200 nodelay;
        limit_req zone=per_ip burst=100 nodelay;

        # 代理设置
        proxy_pass $proxy_target;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # x86_64优化的代理配置
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_connect_timeout 15s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        proxy_buffering on;
        proxy_buffer_size 32k;       # x86优化
        proxy_buffers 32 32k;
        proxy_busy_buffers_size 64k;

        # WebSocket支持
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        # 故障转移
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        proxy_next_upstream_tries 3;
        proxy_next_upstream_timeout 30s;

        # 记录统计信息
        log_by_lua_block {
            local loadbalancer = require "app.loadbalancer"
            local app_type = ngx.var.app_type
            local user_id = ngx.var.user_id
            local instance_name = ngx.var.backend_instance
            local response_time = tonumber(ngx.var.upstream_response_time)

            loadbalancer.update_stats(app_type, user_id, instance_name, response_time)
        }
    }

    # 处理其他路径
    location / {
        content_by_lua_block {
            ngx.header.content_type = "application/json"
            ngx.status = 404
            ngx.say('{"error": "Not Found. Use /v1/ endpoints."}')
        }
    }
}