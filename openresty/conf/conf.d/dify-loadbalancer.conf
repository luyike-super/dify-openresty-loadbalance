# Dify OpenResty负载均衡配置 (x86优化)

# Lua初始化
init_worker_by_lua_block {
    local loadbalancer = require "app.loadbalancer"
    loadbalancer.init()
}

# 限流区域定义（x86性能更强，可以设置更高的限制）
limit_req_zone $binary_remote_addr zone=per_ip:20m rate=200r/s;
limit_req_zone $app_type zone=per_app:20m rate=500r/s;
limit_req_zone $app_type:$user_id zone=per_app_user:50m rate=50r/s;

server {
    listen 80;
    listen [::]:80;
    server_name _;

    # 变量声明
    set $proxy_target "";
    set $app_type "";
    set $user_id "";
    set $backend_instance "";
    set $hash_key "";

    # 多层级日志配置
    # 主访问日志 - 所有请求
    access_log /usr/local/openresty/nginx/logs/access.log json_main;
    
    # 应用路由日志 - 业务请求
    access_log /usr/local/openresty/nginx/logs/app_routing.log app_routing;
    
    # 安全审计日志 - 安全相关事件
    access_log /usr/local/openresty/nginx/logs/security_audit.log security_audit if=$log_security;
    
    # 性能监控日志 - 慢请求和性能指标
    access_log /usr/local/openresty/nginx/logs/performance.log performance if=$log_performance;
    
    # 错误日志 - 多级别错误记录
    error_log /usr/local/openresty/nginx/logs/error.log warn;
    error_log /usr/local/openresty/nginx/logs/error_detail.log info;
    
    # 控制台输出（开发环境）
    access_log /dev/stdout app_routing;
    error_log /dev/stdout info;
    
    # 日志条件变量
    set $log_security 0;
    set $log_performance 0;
    
    # 安全事件条件：认证失败、异常状态码、可疑请求
    if ($status ~ "^(401|403|429|5..)$") {
        set $log_security 1;
    }
    
    # 性能监控条件：慢请求、大响应
    if ($request_time ~ "^[1-9]") {
        set $log_performance 1;
    }
    
    if ($body_bytes_sent ~ "^[0-9]{7,}") {
        set $log_performance 1;
    }

    # 安全头设置
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-Served-By "openresty-x86_64" always;

    # 健康检查
    location /health {
        access_log off;
        content_by_lua_block {
            ngx.say("healthy")
        }
    }

    # 负载均衡状态
    location /status {
        access_log off;
        content_by_lua_block {
            local loadbalancer = require "app.loadbalancer"
            local cjson = require "cjson"

            ngx.header.content_type = "application/json"

            local stats = loadbalancer.get_stats()
            local status = {
                status = "running",
                architecture = "x86_64",
                algorithm = "consistent_hash",
                stats = stats,
                timestamp = ngx.time()
            }

            ngx.say(cjson.encode(status))
        }
    }

    # 配置重载
    location /reload-config {
        access_log off;
        content_by_lua_block {
            -- 清空Hash环缓存，强制重新加载配置
            local hash_ring_dict = ngx.shared.hash_ring
            hash_ring_dict:flush_all()

            local loadbalancer = require "app.loadbalancer"
            loadbalancer.init()

            ngx.header.content_type = "application/json"
            ngx.say('{"status": "success", "message": "Configuration reloaded"}')
        }
    }

    # 主要API路由
    location /v1/ {
        # Lua变量声明
        set $app_type "";
        set $user_id "";
        set $backend_instance "";
        set $hash_key "";

        # 请求处理
        access_by_lua_block {
            local loadbalancer = require "app.loadbalancer"
            local log_security = require "log_security"
            
            -- 执行安全检查
            log_security.security_check()
            
            -- 记录请求详情
            ngx.log(ngx.INFO, "[REQUEST] Processing request - ",
                   "URI: ", ngx.var.request_uri,
                   ", Method: ", ngx.var.request_method,
                   ", Remote IP: ", ngx.var.remote_addr,
                   ", User Agent: ", ngx.var.http_user_agent or "unknown")

            -- 1. 提取用户Token
            local auth_header = ngx.var.http_authorization
            ngx.log(ngx.INFO, "[DEBUG] Authorization header: ", auth_header or "nil")
            
            local user_token = ""
            if auth_header then
                user_token = string.match(auth_header, "Bearer%s+(.+)")
                ngx.log(ngx.INFO, "[DEBUG] Extracted user_token: ", user_token or "nil")
            else
                ngx.log(ngx.WARN, "[DEBUG] No Authorization header found")
            end

            -- 2. 验证Token并获取应用类型
            local app_type = loadbalancer.get_app_type(user_token)
            ngx.log(ngx.INFO, "[DEBUG] App type result: ", app_type or "nil")
            
            if not app_type then
                ngx.log(ngx.ERR, "[ERROR] Token validation failed for token: ", user_token or "nil")
                ngx.status = 401
                ngx.header.content_type = "application/json"
                ngx.say('{"error": "Invalid or missing authorization token"}')
                ngx.exit(401)
            end

            -- 3. 获取用户ID
            local user_id = loadbalancer.get_user_id()
            if not user_id then
                ngx.status = 400
                ngx.header.content_type = "application/json"
                ngx.say('{"error": "User ID required via X-User-ID header, user_id parameter, cookie, JSON body user field, or form-data user field"}')
                ngx.exit(400)
            end

            -- 4. 获取后端实例
            local instance, hash_key = loadbalancer.get_backend_instance(app_type, user_id)
            if not instance then
                ngx.status = 503
                ngx.header.content_type = "application/json"
                ngx.say('{"error": "Service temporarily unavailable"}')
                ngx.exit(503)
            end

            -- 5. 设置变量供后续使用
            ngx.var.app_type = app_type
            ngx.var.user_id = user_id
            ngx.var.backend_instance = instance.name
            ngx.var.hash_key = hash_key

            -- 6. 设置代理目标
            local proxy_url = "http://" .. instance.host .. ":" .. instance.port
            ngx.var.proxy_target = proxy_url

            -- 7. 设置真实Dify Token
            ngx.req.set_header("Authorization", "Bearer " .. instance.token)

            -- 8. 设置调试头
            ngx.req.set_header("X-App-Type", app_type)
            ngx.req.set_header("X-Dify-Instance", instance.name)
            ngx.req.set_header("X-User-ID-Used", user_id)
            ngx.req.set_header("X-Hash-Key", hash_key)
            ngx.req.set_header("X-LB-Architecture", "x86_64-OpenResty")
        }

        # 限流配置
        limit_req zone=per_app_user burst=100 nodelay;
        limit_req zone=per_app burst=200 nodelay;
        limit_req zone=per_ip burst=100 nodelay;

        # 代理设置
        proxy_pass $proxy_target;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # x86_64优化的代理配置
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_connect_timeout 15s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        proxy_buffering on;
        proxy_buffer_size 32k;       # x86优化
        proxy_buffers 32 32k;
        proxy_busy_buffers_size 64k;

        # WebSocket支持
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        # 故障转移
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        proxy_next_upstream_tries 3;
        proxy_next_upstream_timeout 30s;

        # 记录统计信息和详细错误日志
        log_by_lua_block {
            local loadbalancer = require "app.loadbalancer"
            local log_security = require "log_security"
            local cjson = require "cjson"
            
            local app_type = ngx.var.app_type
            local user_id = ngx.var.user_id
            local instance_name = ngx.var.backend_instance
            local response_time = tonumber(ngx.var.upstream_response_time)
            local request_time = tonumber(ngx.var.request_time)
            local status = ngx.status
            local upstream_status = ngx.var.upstream_status
            local body_bytes_sent = tonumber(ngx.var.body_bytes_sent)
            
            -- 企业级错误日志记录
            if status >= 400 then
                local error_details = {
                    timestamp = ngx.utctime(),
                    request_id = ngx.var.request_id,
                    level = "error",
                    remote_addr = ngx.var.remote_addr,
                    request_method = ngx.var.request_method,
                    request_uri = log_security.sanitize_data(ngx.var.request_uri),
                    status = status,
                    upstream_status = upstream_status,
                    upstream_addr = ngx.var.upstream_addr,
                    app_type = app_type,
                    user_id = user_id,
                    backend_instance = instance_name,
                    request_time = request_time,
                    upstream_response_time = response_time,
                    body_bytes_sent = body_bytes_sent,
                    user_agent = log_security.sanitize_data(ngx.var.http_user_agent),
                    x_forwarded_for = ngx.var.http_x_forwarded_for
                }
                
                ngx.log(ngx.ERR, "[ERROR_DETAIL] ", cjson.encode(error_details))
                
                -- 记录安全事件（如果是安全相关错误）
                if status == 401 or status == 403 or status == 429 then
                    log_security.log_security_event("authentication_failure", {
                        status = status,
                        uri = ngx.var.request_uri,
                        user_agent = ngx.var.http_user_agent,
                        app_type = app_type,
                        user_id = user_id
                    })
                end
            end
            
            -- 性能监控日志
            if request_time and request_time > 1.0 then  -- 慢请求
                local perf_log = {
                    timestamp = ngx.utctime(),
                    request_id = ngx.var.request_id,
                    event_type = "slow_request",
                    request_time = request_time,
                    upstream_response_time = response_time,
                    app_type = app_type,
                    backend_instance = instance_name,
                    uri = log_security.sanitize_data(ngx.var.request_uri),
                    status = status,
                    body_bytes_sent = body_bytes_sent
                }
                
                ngx.log(ngx.WARN, "[PERFORMANCE] ", cjson.encode(perf_log))
            end
            
            -- 大响应监控
            if body_bytes_sent and body_bytes_sent > 10485760 then  -- 10MB
                local large_response_log = {
                    timestamp = ngx.utctime(),
                    request_id = ngx.var.request_id,
                    event_type = "large_response",
                    body_bytes_sent = body_bytes_sent,
                    app_type = app_type,
                    backend_instance = instance_name,
                    uri = log_security.sanitize_data(ngx.var.request_uri)
                }
                
                ngx.log(ngx.WARN, "[PERFORMANCE] ", cjson.encode(large_response_log))
            end

            -- 更新统计信息
            loadbalancer.update_stats(app_type, user_id, instance_name, response_time)
        }
    }

    # 处理其他路径
    location / {
        content_by_lua_block {
            ngx.header.content_type = "application/json"
            ngx.status = 404
            ngx.say('{"error": "Not Found. Use /v1/ endpoints."}')
        }
    }
}